# 8. 프록시와 연관관계 관리

## 8.1 프록시

JPA는 엔티티가 실제 사용될 때까지 데이터베이스 조회를 지연하는 방법을 제공하는데 이것을 **지연 로딩**이라한다. 그런데 지연 로딩 기능을 사용하려면 실제 엔티티 객체 대신에 데이터베이스 조회를 지연할 수 있는 가짜 객체가 필요한데 이것을 **프록시 객체**라 한다. 

### 8.1.1 프록시 기초

* `em.find()`: 데이터베이스를 통해서 실제 엔티티 객체 조회
* `em.getReference()`: 데이터베이스 조회를 미루는 가짜(프록시) 엔티티 객체 조회 

#### 프록시
* 실제 클래스를 상속 받아서 만들어진다.
* 실제 클래스와 겉 모양이 같다.
* 프록시 객체는 실제 객체의 참조를 보관한다.
* 프록시 객체를 호출하면 프록시 객체는 실제 객체의 메소드를 호출한다. 

#### 프록시의 초기화 과정
1. 프록시 객체에 `member.getName()`을 호출해서 실제 데이터를 조회한다.
2. 프록시 객체는 실제 엔티티가 생성되어 있지 않으면 영속성 컨텍스트에 실제 엔티티 생성을 요청하는데 이것을 초기화라 한다.
3. 영속성 컨텍스트는 데이터베이스를 조회해서 실제 엔티티 객체를 생성한다.
4. 프록시 객체는 생성된 실제 엔티티 객체의 참조를 `Member target` 멤버변수에 보관한다.
5. 프록시 객체는 실제 엔티티 객체의 `getName()`을 호출해서 결과를 반환한다. 

#### 프록시의 특징
* 프록시 객체는 처음 사용할 때 한 번만 초기화된다.
* 프록시 객체를 초기화한다고 **프록시 객체가 실제 엔티티로 바뀌는 것은 아니다.** 프록시 객체가 초기화되면 프록시 객체를 통해서 실제 엔티티에 접근할 수 있다. 
* 프록시 객체는 **원본 엔티티를 상속**받은 객체이므로 타입 체크 시에 주의해야 한다.
* **영속성 컨텍스트에 찾는 엔티티가 이미 있으면 `em.getReference()`를 호출해도 실제 엔티티를 반환한다.**
* 영속성 컨텍스트의 도움을 받을 수 없는 준영속 상태의 프록시를 초기화하면 문제가 발생한다.  

## 8.2 즉시 로딩과 지연 로딩

처음부터 연관된 엔티티를 모두 영속성 컨텍스트에 올려두는 것은 현실적이지 않고, 필요할 때마다 SQL을 실행해서 연관된 엔티티를 지연 로딩하는 것도 최적화 관점에서 보면 꼭 좋은 것만은 아니다. 그러나 추천하는 방법은 **모든 연관관계에 지연 로딩을 사용**하는 것이다. 

* 지연 로딩(LAZY): 연관된 엔티티를 프록시로 조회한다. 프록시를 실제 사용할 때 초기화하면서 데이터베이스를 조회한다.
* 즉시 로딩(EAGER): 연관된 엔티티를 즉시 조회한다. 하이버네이트는 가능하면 SQL 조인을 사용해서 한 번에 조회한다. 

## 8.3 지연 로딩 활용

### 8.3.2 JPA 기본 페치 전략 

JPA의 기본 페치<sub>fetch</sub> 전략은 연관된 엔티티가 하나면 즉시 로딩을, 컬렉션이면 지연 로딩을 사용한다. 

* `@ManyToOne`, `@OneToOne`: 즉시 로딩(`FetchType.EAGER`)
* `@OneToMany`, `@ManyToMany`: 지연 로딩(`FetchType.LAZY`)

추천하는 방법은 모든 연관관계에 지연 로딩을 사용하는 것이다. 따라서 `@ManyToOne`, `@OneToOne`의 경우 직접 `FetchType.LAZY`로 설정해주어야 한다. 

## 8.4 영속성 전이: CASCADE

특정 엔티티를 영속 상태로 만들 때 연관된 엔티티도 함께 영속 상태로 만들고 싶으면 영속성 전이<sub>transitive persistence</sub>기능을 사용하면 된다. JPA는 `CASCADE` 옵션으로 영속성 전이를 제공한다. 

## 8.5 고아 객체

JPA는 부모 엔티티와 연관관계가 끊어진 자식 엔티티를 자동으로 삭제하는 기능을 제공하는데 이것을 고아 객체(ORPHAN) 제거라 한다. 이 기능을 사용하면 **부모 엔티티의 컬렉션에서 자식 엔티티의 참조만 제거하면 자식 엔티티가 자동으로 삭제**된다.

* 특정 엔티티가 개인 소유하는 엔티티에만 이 기능을 적용해야 한다. 
* 만약 삭제한 엔티티를 다른 곳에서도 참조한다면 문제가 발생할 수 있다.
* 이런 이유로 `orphanRemoval`은 `@OneToOne`, `@OneToMany`에만 사용할 수 있다. 

## 8.6 영속성 전이 + 고아 객체, 생명주기

`CascadeType.All` 와 `orphanRemoval = true` 두 옵션을 모두 활성화하면 부모 엔티티를 통해서 자식의 생명주기를 관리할 수 있다. 
* 자식을 저장하려면 부모에 등록만 하면 된다(`CASCADE`)
* 자식을 삭제하려면 부모에서 제거하면 된다(`orphanRemoval`) 