# 7. 고급 매핑

## 7.1 상속 관계 매핑

RDB에는 OOP에서 다루는 상속이라는 개념이 없다. 대신에 슈퍼타입 서브타입 관계<sub>Super-Type Sub-Type Relationship</sub>라는 모델링 기법이 객체의 상속 개념과 가장 유사하다. ORM에서 이야기하는 상속 관계 매핑은 객체의 상속 구조와 데이터베이스의 슈퍼타입 서브타입 관계를 매핑하는 것이다. 

그리고 그 방법 3가지 
* 조인 전략: 각각의 테이블로 변환 (정석)
* 단일 테이블 전략: 통합 테이블로 변환 (데이터가 단순할 때)
* 구현 클래스마다 테이블 전략: 서브타입 테이블로 변환 (실무 사용 X)

### 7.1.1 조인 전략<sub>Joined Strategy</sub>

엔티티 각각을 모두 테이블로 만들고 자식 테이블이 부모 테이블의 기본키를 받아서 기본 키 + 외래 키로 사용하는 전략. 타입을 구분하는 컬럼(`DTYPE`)이 필요하다. 

* 장점
  * 테이블이 정규화된다. 
  * 외래 키 참조 무결성 제약조건을 활용할 수 있다.
  * 저장공간을 효율적으로 사용한다. 

* 단점
  * 조인이 많이 사용되므로 성능이 저하될 수 있다. (큰 문제 X)
  * 조회 쿼리가 복잡하다. 
  * 데이터를 등록할 INSERT SQL을 두 번 실행한다. 


### 7.1.2 단일 테이블 전략<sub>Single-Table Strategy</sub>

테이블을 하나만 사용하고 구분 컬럼(`DTYPE`)을 필수로 사용한다.

* 장점
  * 조인이 필요 없으므로 조회 성능이 빠르다.
  * 조회 쿼리가 단순하다.

* 단점
  * **자식 엔티티가 매핑한 컬럼은 모두 `null`을 허용해야 한다.**
  * 테이블이 커지면 조회 성능이 오히려 느려질 수 있다. 

## 7.2 @MappedSuperclass

엔티티들이 공통적으로 사용하는 매핑 정보를 상속하기 위해 사용된다.        
예) 등록일자, 수정일자, 등록자, 수정자

### `@MappedSuperclass`의 특징
* 테이블과 매핑되지 않는다.
* `@MappedSuperclass`로 지정한 클래스는 엔티티가 아니므로 `em.find()`나 JPQL에서 사용할 수 없다. 
* 이 클래스를 직접 생성해서 사용할 일은 거의 없으므로 추상 클래스로 만드는 것을 권장한다. 

#### 참고
엔티티(`@Entity`)는 엔티티(`@Entity`) 또는 `@MappedSuperclass`로 지정한 클래스만 상속받을 수 있다. 